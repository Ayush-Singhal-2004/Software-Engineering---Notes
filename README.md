<h1>Unit 1</h1>
<h3>1. What is Software Engineering?</h3>
- Software Engineering consists of two words software and engineering, where Software can be defined as a collection of computer programs, which in turn is a collection of commands. Engineering on the other hand, is all about developing products, using well-defined, scientific principles and methods.</br>
- Software Engineering is a systemic, well disciplined ,cost effective techniques for software development. The outcome of software engineering is an efficient and reliable software product</br>

<h3>2. What is Agile Process?</h3>
- Agile means changes, & to adapt those changes. Agile is a project management methodology that breaks down larger projects into smaller, manageable chunks known as iterations. At the end of every iteration something of value is produced. The product that’s produced during every iteration should be able to be placed into the world to receive feedback from stakeholders or users.</br></br>
- Phases of Agile Process :</br>
i. Requirement gathering and analysis </br>
ii. Design the requirements</br>
iii. Construction/ iteration</br>
iv. Deployment</br>
v. Testing</br>
vi. Feedback</br></br>
- Advantages :</br>
i. Project is divided into short and transparent iterations.</br>
ii. It minimizes the risk of software development.</br>
iii. Quick release of the first product version.</br>
iv. Customer can see the result and understand whether he/she is satisfied with it or not.</br>
v. It has a flexible change process.</br></br>
- Disadvantages :</br>
i. The development team should be highly professional and client-oriented.</br>
ii. New requirement may be a conflict with the existing architecture.</br>
iii. With further correction and change, there may be chances that the project will cross the expected time.</br>
iv. There may be difficult to estimate the final cost of the project due to constant iteration.</br></br>

![](https://images.ctfassets.net/4zfc07om50my/5wMHnK8XxK9kW99mebdp94/2cc919cd11ba35f6db993977fd0ff674/Agile.png)

<h3>3.Why do we need requirement validation?</h3>
- Requirement validation is necessary in software engineering because it helps ensure that the software being developed meets the needs and expectations of its users. It ensures accuracy, completeness, and consistency of the requirements, helping to prevent misunderstandings and costly errors later in the development process. Requirement validation also checks feasibility, ensuring that the proposed features can be implemented within the project's constraints. Overall, it helps mitigate risks, aligns the software with project goals, and enhances stakeholder satisfaction. </br>

<h3>4. Distinguish between software process, software project, and software product?</h3>
- Software Process : </br>
i. The software process refers to the set of activities, methods, practices, and transformations that are used to develop and maintain software systems. </br>
ii. It encompasses the entire lifecycle of software development, including planning, requirements analysis, design, implementation, testing, deployment, maintenance, and eventual retirement or replacement of the software. </br>
iii. Software processes can vary widely depending on the development methodology used (e.g., waterfall, agile, iterative, spiral, etc.), organizational policies, and project requirements.</br></br>
- Software Project :</br>
i. A software project is a temporary attempt undertaken to create a unique software product, service, or result.</br>
ii. It has a defined scope, timeline, budget, and resources allocated to achieve specific objectives.</br>
iii. Software projects typically follow a software process to guide the development activities from inception to completion.</br>
iv. Examples of software projects include developing a new mobile application, creating an enterprise software system, or implementing a custom solution for a client.</br></br>
- Software Product : </br>
i. A software product is the tangible outcome or deliverable of a software project. </br>
ii. It is the actual software system, application, or solution that fulfills user needs or requirements.</br>
iii. Software products can be commercial off-the-shelf (COTS) products, custom-built applications, or open-source software. </br>
iv. Once developed, a software product undergoes maintenance, updates, and enhancements throughout its lifecycle to address bugs, add new features, or adapt to changing requirements.</br></br>

<h3>5. What is importance of Software Engineering?</h3>
i. Facilitates Reliable Software Development: Software engineering provides systematic methodologies and best practices that ensure the development of reliable, robust, and high-quality software products. </br>
ii. Ensures Cost-Effectiveness: Effective software engineering practices help in optimizing resource allocation, reducing development costs, and maximizing return on investment.</br>
iii. Supports Scalability and Maintainability: Software engineering principles emphasize modularity, reusability, and scalability, enabling software systems to accommodate growth and adapt to evolving business needs. Well-designed software architectures and coding standards facilitate easier maintenance, updates, and enhancements, ensuring that software products remain relevant and functional over time.</br>
iv. Enhances Productivity and Efficiency: By adopting standardized development practices, automated tools, and collaborative workflows, software engineering enables teams to work more efficiently and productively.</br>
v. Improves Software Security and Reliability: With the increasing prevalence of cybersecurity threats and data breaches, software engineering plays a critical role in ensuring the security and reliability of software systems. By integrating security measures, conducting thorough testing, and adhering to coding standards and security protocols, software engineers can mitigate vulnerabilities, protect sensitive data, and enhance the overall security posture of software products.</br></br>

<h3>6. Write a critical analysis of Waterfall Model?</h3>
i. Waterfall model is an example of a Sequential model. In this model, the software development activity is divided into different phases and each phase consists of series of tasks and has different objectives. It is divided into phases and output of one phase becomes the input of the next phase. </br>
ii. It is mandatory for a phase to be completed before the next phase starts. In short, there is no overlapping in Waterfall model. Since the phases fall from higher level to lower level, like a waterfall, It’s named as waterfall model. </br></br>
- Problems with Waterfall model : </br>
i. Sequential Nature, which is not realistic.</br>
ii. Not suitable to accommodate the change. </br>
iii. Working software is not available till very late in the Software development cycle. </br>
iv. Expects complete & accurate requirements early in software development process. </br></br>

![](https://miro.medium.com/v2/resize:fit:500/1*tGKCSfTfV8E8t4atqrLE4A.png)

</br></br>

<h3>7. Mention some of the factors to be considered during system modeling?</h3>
- During system modeling in software engineering, several factors need to be considered to ensure the accuracy, completeness, and effectiveness of the models. Some of these factors include : </br></br>
i. Requirements : The system model should accurately represent the requirements of the stakeholders. Understanding and documenting user needs, functional requirements, and non-functional requirements is essential for creating a comprehensive system model. </br>
ii. Scope: Clearly define the scope of the system model to ensure that it focuses on the relevant aspects of the system under consideration. Avoid unnecessary complexity by keeping the scope well-defined and manageable. </br>
iii. Consistency: Ensure that the various components of the system model are consistent with each other and with other project artifacts such as requirements documents, design specifications, and implementation code. </br>
iv. Accuracy: Strive for accuracy in the system model by validating assumptions, verifying information with subject matter experts, and conducting reviews and inspections to identify and correct errors or inconsistencies. </br>
v. Flexibility: Design the system model to be flexible and adaptable to accommodate changes and updates throughout the software development lifecycle. Agile modeling techniques such as iterative refinement and continuous feedback can help maintain flexibility in the modeling process. </br>
vi. Documentation: Document the system model thoroughly to provide clarity and context for stakeholders and future development efforts. Include explanations, assumptions, constraints, and rationale behind design decisions to aid understanding and facilitate maintenance. </br>
vii. Tool Support: Utilize appropriate modeling tools and techniques to create, manage, and communicate the system model effectively. Choose tools that align with the project's requirements, team expertise, and budget constraints. </br>
viii. Validation and Verification: Validate and verify the system model against the requirements and specifications to ensure that it accurately represents the desired system behavior and characteristics. Use techniques such as simulation, prototyping, and formal verification to identify and resolve discrepancies. </br>

<h3>8. Differentiate between data flow diagram and state transition diagram?</h3>
- A Data Flow Diagram (DFD) and a State Transition Diagram (STD) are both graphical representations used in software engineering, but they serve different purposes and depict different aspects of a system : </br> 
i. Data Flow Diagram (DFD) : </br>
- DFDs represent the flow of data within a system and illustrate how data moves between processes, data stores, and external entities. </br>
- DFDs consist of processes, data stores, data flows, and external entities. </br>
- Represent activities or transformations performed on data within the system. </br>
- Represent repositories where data is stored within the system. </br>
- DFDs can be decomposed into multiple levels of detail, with higher levels showing broader system perspectives and lower levels providing more detailed views of processes and data flows. </br>
- Represent sources or destinations of data outside the system boundary. </br></br>
ii. State Transition Diagram (STD) : </br> 
- STDs represent the behavior of a system or component in response to events and illustrate how the system transitions between different states. </br>
- STDs consist of states, events, and transitions. </br>
- Represent the various conditions or modes that a system or component can be in at a given time. </br>
- Represent external stimuli or triggers that cause the system to transition between states. </br>
- Represent the change of state in response to events. </br>
- STDs may also depict conditions or actions associated with state transitions, indicating what actions should be performed when transitioning between states. </br>

<h3>9. Define software development life cycle?</h3>
- Software Development Life Cycle, SDLC for short, is a well-defined, structured sequence of stages in software engineering to develop the intended software product. </br>
- It consists of a detailed plan describing how to develop, maintain, replace and alter or enhance a specific software. </br></br>
- Stages of software development life cycle are : </br></br>
i. Planning and requirement analysis : </br>
- Planning and Requirement analysis is the most important and fundamental stage in SDLC. It is performed by the senior members of the team with inputs from the customer, the sales department, market surveys and domain experts in the industry.  </br>
- This information is then used to plan the basic project approach and to conduct product feasibility study in the economical, operational and technical areas. </br></br>
ii. Defining requirement : </br>
- Once the requirement analysis is done the next step is to clearly define and document the product requirements and get them approved from the customer or the market analysts. </br>
- This is done through an SRS (Software Requirement Specification) document which consists of all the product requirements to be designed and developed during the project life cycle. </br></br>
iii. Designing : </br>
- SRS is the reference for product architects to come out with the best architecture for the product to be developed. </br>
- Based on the requirements specified in SRS, usually more than one design approach for the product architecture is proposed and documented in a DDS - Design Document Specification. </br>
- A design approach clearly defines all the architectural modules of the product along with its communication and data flow representation with the external and third party modules. </br> </br>
iv. Building or Developing the Product : </br>
- In this stage of SDLC the actual development starts and the product is built.  </br>
- The programming code is generated as per DDS during this stage. Different high level programming languages such as C, C++, Pascal, Java and PHP are used for coding. </br>
- The programming language is chosen with respect to the type of software being developed. </br></br>
v. Testing the Product : </br>
- This stage is usually a subset of all the stages as in the modern SDLC models, the testing activities are mostly involved in all the stages of SDLC. </br>
- However, this stage refers to the testing only stage of the product where product defects are reported, tracked, fixed and retested, until the product reaches the quality standards defined in the SRS. </br></br>
vi. Deployment in the Market and Maintenance : </br>
- Once the product is tested and ready to be deployed it is released formally in the appropriate market. Sometimes product deployment happens in stages as per the business strategy of that organization. </br>
- The product may first be released in a limited segment and tested in the real business environment. </br>
- Then based on the feedback, the product may be released as it is or with suggested enhancements in the targeting market segment. </br>
- After the product is released in the market, its maintenance is done for the existing customer base. </br>

<h3>10. How does system engineering differ from software engineering? Also write brief notes on
computer based system and system engineering hierarchy?</h3>
- System engineering and software engineering are related disciplines within the broader field of engineering, but they focus on different aspects of complex systems : </br> </br>
i. System Engineering vs. Software Engineering : </br> </br>
- <h5>System Engineering</h5> : System engineering is concerned with designing, analyzing, and managing complex systems that may include hardware, software, people, processes, and other components. It involves a holistic approach to system development, considering the interactions and dependencies between various subsystems and components. System engineers focus on defining system requirements, architecture, integration, and optimization to ensure that the system as a whole meets its objectives and performs reliably within its operational environment. </br></br>
- <h5>Software Engineering </h5>: Software engineering, on the other hand, specifically focuses on the design, development, testing, and maintenance of software systems. It deals with the software component of a system and involves processes, methodologies, and techniques for building high-quality software products efficiently and effectively. Software engineers are concerned with software requirements analysis, design patterns, coding practices, testing methodologies, and software project management. </br></br>
ii. Computer - Based System : </br></br>
- A computer-based system is a system that relies on the use of computers and software to perform various functions and tasks. It typically consists of hardware components such as computers, processors, memory, storage devices, input/output devices, and networking infrastructure, as well as software components such as operating systems, applications, and databases. </br>
- Computer-based systems are widely used in various domains and industries, including business, finance, healthcare, education, entertainment, and manufacturing. Examples of computer-based systems include enterprise resource planning (ERP) systems, customer relationship management (CRM) systems, electronic medical record (EMR) systems, online banking systems, and video game consoles. </br>
- Computer-based systems are designed to automate processes, enhance productivity, improve decision-making, enable communication and collaboration, and support various business functions and activities. </br></br>
iii. System Engineering Hierarchy : </br></br>
- System-of-Interest (SoI): At the top of the system engineering hierarchy is the System-of-Interest (SoI), which represents the entire system being analyzed, designed, or managed. The SoI includes all components, subsystems, interfaces, and interactions that contribute to the overall system functionality and behavior. </br>
- System Element : System elements are the individual components or subsystems that make up the System-of-Interest. These may include hardware components, software components, people, processes, facilities, and other resources necessary for system operation. </br>
- Subsystem : Subsystems are collections of system elements that work together to perform specific functions or tasks within the System-of-Interest. Subsystems may be further divided into smaller subsystems or components to facilitate analysis, design, and integration. </br>
- Component : Components are the lowest level of the system engineering hierarchy and represent the smallest functional units or building blocks of the system. Components may include individual hardware devices, software modules, sensors, actuators, interfaces, and other discrete entities. </br>
- The system engineering hierarchy provides a structured framework for understanding the complex relationships and dependencies between system elements and for managing the system development lifecycle from requirements definition to system deployment and operation. </br>

<h3>11. Explain the requirement engineering process and its outcomes?</h3>
- It is the Process of defining, documenting & maintaining the requirements. It provides the appropriate mechanism to find what the customer needs. </br>
- Sources of Requirements : </br>
i. Documents </br>
ii. Existing System </br>
iii. Domain/Business Area </br>
- Example of Software Requirements : The System/Software Shall maintain records of all payments made to employees on account of salaries,bonuses,travel allowances, medical allowances etc. </br>
- Requirement Engineering Process : 
i. Feasibility Study </br>
ii. Requirement Elicitation and Analysis </br>
iii. Software Requirement Specification </br>
iv. Software Requirement Validation </br></br>

![](data:image/png;base64,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)
</br></br>

- Requirement engineering is the process of eliciting, analyzing, documenting, and managing the requirements of a software system. It is a crucial phase in the software development lifecycle as it forms the foundation for designing and building the software product. Here's an explanation of the requirement engineering process and its outcomes : </br>
i. Elicitation: The requirement engineering process begins with eliciting requirements from stakeholders. Stakeholders may include end-users, customers, managers, domain experts, and other individuals or groups who have a vested interest in the software system.  </br>
ii. Analysis: Once requirements are elicited, they are analyzed to understand their scope, priority, and feasibility. Requirements analysis involves identifying stakeholders' needs, resolving conflicts or inconsistencies in requirements, and defining functional and non-functional requirements. </br></br>
![](https://jelvix.com/wp-content/uploads/2020/05/difference-between-functional-vs-nonfunctional-966x670.jpg)
</br></br>
iii. Specification: The next step in the requirement engineering process is to document the requirements in a formal and structured manner. Requirements are documented using various artifacts such as requirement documents, use cases, user stories, and prototypes. </br>
iv. Validation: Once requirements are documented, they need to be validated to ensure that they accurately capture the stakeholders' needs and expectations. </br>
v. Management: Requirements management involves managing changes to the requirements throughout the software development lifecycle. Changes may arise due to evolving business needs, technology advancements, or stakeholder feedback. </br>
vi. Communication: Effective communication is essential throughout the requirement engineering process to ensure that stakeholders have a clear understanding of the requirements and their implications. </br>
vii. Outcomes : </br>
- Requirements Document: The primary outcome of the requirement engineering process is a comprehensive requirements document that describes the functional and non-functional requirements of the software system. </br>
- Traceability Matrix: A traceability matrix is used to trace requirements back to their source and forward to design and implementation artifacts. It helps ensure that all requirements are addressed and implemented correctly. </br>
- Prototype or Mockups: Prototypes or mockups may be developed to visualize and validate the requirements with stakeholders. These prototypes help ensure that the final software product meets the stakeholders' expectations. </br>
- Change Control Mechanism: A change control mechanism is established to manage changes to the requirements throughout the software development lifecycle. It helps ensure that changes are properly evaluated, approved, and implemented while minimizing the impact on project scope and schedule. </br></br>

<h3>12. What is meant by software quality? Explain the metrics for maintenance?</h3>
- Software quality refers to the degree to which a software product or system meets specified requirements and user expectations. It encompasses various attributes such as reliability, functionality, usability, efficiency, maintainability, portability, and security. Achieving high software quality is essential to ensure that the software meets user needs, performs reliably, and delivers value to stakeholders. </br></br>
- Metrics for maintenance in software engineering refer to quantitative measures used to assess and evaluate the maintenance activities performed on a software system. Maintenance metrics help software teams monitor the effectiveness, efficiency, and quality of maintenance activities, identify areas for improvement, and make data-driven decisions to optimize the maintenance process. Some common metrics for maintenance include : </br></br>
i. Defect Density : Defect density measures the number of defects or bugs identified per unit of software size, such as lines of code or function points. Monitoring defect density helps track the quality of software releases and identify trends in defect rates over time. </br>
ii. Code Churn: Code churn measures the rate of change or modification to the software codebase over a specific period. High code churn may indicate instability in the software and increased risk of introducing defects during maintenance activities. </br>
iii. Percentage of Reopened Issues: This metric measures the percentage of issues or defects that are reopened or resurface after being marked as resolved. A high percentage of reopened issues may indicate inadequate testing or incomplete resolution of problems during maintenance. </br>
iv. Change Request Backlog: Change request backlog measures the number of pending change requests or enhancement requests awaiting implementation. Monitoring the backlog helps prioritize maintenance activities and manage resource allocation effectively. </br>
v. Customer Satisfaction Score (CSAT): CSAT measures the satisfaction level of customers or end-users with the maintenance and support services provided. Regular surveys or feedback mechanisms can be used to collect CSAT data and identify areas for improvement. </br>

<h1>Unit 2</h1>

<h3>1. What are functional requirements?</h3>
- Functional requirements in software engineering are specifications that outline the specific behaviors, functions, and features that a software system must perform to meet the needs of its users. These requirements describe what the system should do, including its inputs, processing logic, and outputs. In simple terms, functional requirements define the "what" of the system - what actions it should perform and what results it should produce. </br>
- Functional Requirements defines the basic system behavior. They define what the system does or must not do. It defines how the system responds to the input. If the Functional requirements are not met, the system will not work. Abnormal Behaviour is also documented as Functional requirements in the form of Exception Handling.
E.g. when the user enters the information, the system shall sends an approval request. </br></br>
- Example of Functional Requirements : </br>
i. The user shall be able to search either the entire database of patients or select a subset. </br>
ii. Every order shall be allocated a unique identifier(ORDER_ID)which the user shall use to access that order. </br>

<h3>2. What are non-functional requirements?</h3>
- Non-functional requirements in software engineering refer to the criteria that describe the operational aspects of a system rather than its specific behaviors or functionalities. Non-functional requirements address various aspects such as performance, security, reliability, usability, scalability, maintainability, and others. These requirements are crucial for ensuring that the software system meets the expected levels of service and provides a satisfactory user experience. </br>
- These are basically the quality constraints that the system must satisfy according to the project contract. </br>
- They do not affect the basic functionality of the system. Even if these requirements are not met, the system will still perform its basic purpose. </br>
- Must be built into the framework of the software product. Failure to meet a non functional system requirement may take the whole system unusable. </br>

<h3>3. What is the basic concept of software requirements documents?</h3>
- The basic concept of a software requirements document (SRD) is to clearly and comprehensively outline the specifications and expectations for a software project. It serves as a formal agreement between the stakeholders, including clients, users, and developers, regarding what the software should accomplish and how it should function. </br>
- Here are the key points about software requirements documents : </br>
i. Description of the Project </br>
ii. Functional Requirement and Non-functional Requirements </br>
iii. User Interface (UI) Design </br>
iv. Dependencies and Constraints </br>
v. Assumptions and Risks </br>
vi. Acceptance Criteria </br>
vii. Approval and Sign-off </br>

<h3>4. What is meant by requirement management?</h3>
- Requirement management is the process of managing changing requirements during the requirements engineering process and system development. It is a continuous process throughout the project. </br>
- Requirements management enables the development team to identify, control, and track requirements and changes that occur as the software development process. </br>
- The essential activities performed in requirements management are listed below : </br>
i. Recognizing the need for change in the requirements </br>
ii. Establishing a relationship amongst stakeholders and involving them in the requirements engineering process </br>
iii. Identifying and tracking requirements attributes </br>

<h3>5. Define requirement elicitation and analysis?</h3>
- It is a part of requirement engineering process, this is also known as the gathering of requirements. Here, requirements are identified with the help of customers and existing system processes. </br>
- It can be successful only through an effective customer-developer partnership. It is needed to know what the users really need. </br>


<h3>6. Why is traceability an important aspect of requirement management?</h3>
- Traceability means the 'ability to trace something'. Traceability is an important aspect of requirement management in software engineering because it helps ensure that all aspects of the software development process remain aligned with the original requirements and objectives. Here's why traceability is important in simple terms : </br>
i. Maintaining Consistency: Traceability allows developers to track how each requirement is implemented in the software design, development, and testing phases. This ensures that the final product aligns with the initial specifications provided by stakeholders. </br>
ii. Managing Changes: As requirements evolve or change over the course of the project, traceability enables developers to understand the impact of those changes on other parts of the software. It helps them identify which components need to be modified, tested, or revalidated to accommodate the changes effectively. </br>
iii. Ensuring Compliance: Traceability helps ensure that the software meets regulatory or compliance standards by providing a clear link between the requirements and the implemented features. This makes it easier to demonstrate compliance during audits or regulatory inspections. </br>
iv. Facilitating Communication: Traceability fosters effective communication and collaboration among team members, stakeholders, and different project phases. It provides a common understanding of the project's progress and helps stakeholders make informed decisions based on the status of requirements implementation. </br>
v. Supporting Maintenance and Evolution: As the software evolves over time, traceability helps developers understand the rationale behind design decisions and past changes. This knowledge makes it easier to maintain and enhance the software in the future while minimizing the risk of introducing unintended side effects. </br>

<h3>7. Why content system models useful for requirements validation?</h3>
- Content system models, also known as conceptual models, are useful for requirements validation in software engineering for several reasons : </br></br>
i. Clarity and Understanding: Content system models provide a visual representation of the system's structure, components, and relationships. This helps stakeholders, including developers and clients, to gain a clearer understanding of the system's requirements and how they relate to one another. </br></br>
ii. Identification of Ambiguities and Inconsistencies: By creating content system models, inconsistencies and ambiguities in the requirements can be identified more easily. These models help stakeholders to visualize potential conflicts or gaps in the requirements specification, enabling them to address these issues before moving forward with development. </br></br>
iii. Requirement Completeness: Content system models allow stakeholders to verify whether all necessary aspects of the system have been addressed in the requirements specification. If certain components or interactions are missing from the model, it indicates that additional requirements may need to be added to ensure the completeness of the specification. </br></br>
iv. Validation Against User Needs: Content system models help ensure that the requirements align with the needs and expectations of the end users. By visualizing the system from the user's perspective, stakeholders can validate whether the proposed system will meet user requirements and provide the desired functionality and usability. </br></br>
v. Facilitates Communication: Content system models serve as a communication tool that facilitates discussions among stakeholders. They provide a common visual representation that can be used to communicate complex ideas and requirements more effectively, helping to ensure that all parties involved have a shared understanding of the system. </br></br>
vi. Early Detection of Design Flaws: Content system models allow stakeholders to identify potential design flaws or issues early in the development process. By visualizing the system's architecture and interactions, stakeholders can anticipate potential problems and make necessary adjustments to the requirements before significant resources are invested in development. </br>

<h1>Unit 3</h1>

<h3>1. What is component based software engineering?</h3>
- Component based Software Engineering(CBSE) is a process that emphasis the design & construction of computer based system using reusable software “components”. </br>
- It merged from the failure of object oriented development to support effective reuse. </br>
- CBSE views the system as a set off-the-shelf components integrated within appropriate architecture. It does not have any standard development models like UML for SE. </br>
-  CBSE increases quality especially Evolvability & maintainability. It increases productivity. It shortens development time. It is easy to assemble & less costly to build the system constructed from discrete paths.
- A component is a modular, portable, replaceable, and reusable set of well-defined functionality that encapsulates its implementation and exporting it as a higher-level interface. </br></br>

- Properties of Components : </br>
i. Independent </br>
ii. Standardized </br>
iii. Deployable </br>
iv. Documented </br>

</br>

![](data:image/jpeg;base64,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)

</br>

![](https://cdn-gcp.new.marutitech.com/2d22592a_drawbacks_of_component_based_2x_1_b3ccf528b3.png)

</br>

<h3>2. What is component composition?</h3>
- This activity ensures that the Architectural style of the system integrates the software components and form a working system. </br>
- By identifying connection and coordination mechanisms of the system, the architecture describes the composition of the end product. </br>


<h1>Unit 4</h1>

<h3>1. Explain System Design?</h3>
- System design is the process of defining the architecture, components, modules, interfaces, and data for a system to satisfy specified requirements. It encompasses both the high-level structure of the system as well as the detailed design of individual components. Here's a simple explanation of system design : </br>
i. Understanding Requirements: The first step in system design is to understand the requirements of the system. This involves gathering information about what the system should do, how it should behave, and what features it should have. Requirements may come from stakeholders, users, or regulatory bodies. </br></br>
ii. Architectural Design: Once the requirements are understood, the system architect or designer creates a high-level architecture for the system. This includes defining the overall structure of the system, such as its layers, modules, and components, and how they interact with each other. </br></br>
iii. Component Design: After defining the architecture, the system designer breaks down the system into smaller components or modules. Each component is designed to perform specific tasks or functions within the system. The designer defines the interfaces between components to ensure they can communicate and work together effectively. </br></br>
iv. Data Design: In addition to defining components, system design also involves designing the data model for the system. This includes defining the types of data the system will use, how it will be stored, organized, and accessed, and any data transformations or processing that need to occur. </br></br>
v. Interface Design: Interfaces are the points of interaction between different components or between the system and its users. System design includes designing user interfaces (such as graphical user interfaces or command-line interfaces) as well as interfaces between system components (such as APIs or message formats). </br></br>
vi. Prototyping and Testing: Once the system design is complete, prototypes may be built to validate the design and test its functionality. This allows designers to identify any issues or limitations early in the development process and make necessary adjustments. </br></br>
vii. Documentation: Throughout the system design process, documentation is created to capture design decisions, rationale, and specifications. This documentation serves as a reference for developers, testers, and other stakeholders throughout the development lifecycle. </br></br>

<h3>2. What is detailed design?</h3>
- Detailed design in software engineering is the phase where the overall system architecture and requirements are broken down into more specific and detailed components. It's like creating a blueprint for building a house after you've already designed the floor plan. </br> </br>
- Phases of Detailed system design : </br> </br>
i. Project planning and control : The first step in the detailed design is planning and controlling, so that standards may be established and a proper follow-up is made. </br></br> 
ii. Involve the User : System designers must inform the user regarding the new information system being developed and gain their support and acceptance. </br></br>
iii. Define the detailed sub system : In detailed system design, every system needs to be broken down to ascertain all activities required and their respective inputs and outputs. </br></br>
iv. Input/output Design : Having defined the subsystem well, by way of flow diagrams and a through discussion with the users of MIS. These specifications will later be used by programmers to develop programs to actually produce the output/input.  </br></br>
v. Feedback from the user : In this phase the designers once again involve the user to get feedback. This step will also reassure the top management of the user organization that the detailed design project is processing as per plans. </br></br>
vi. Database Design : A database is an orderly arrangement of all the records related to each other. It serves as a data resource for the MIS of an organization. </br></br>
vii. Procedure Design : Procedures are the rules, standards or methods designed to increase the effectiveness of the information system. </br></br>
viii. Design Documentation : Detailed design starts with the performance specifications given by the conceptual design and ends with a set of design specifications for the construction of MIS. </br></br>

<h3>3. Define Function Oriented Design?</h3>
- Function Oriented Design is an approach to software design where the design is decomposed into a set of interacting units where each unit has a clearly defined function. </br>
- Function-oriented design, also known as procedural design, is an approach to software design that focuses on decomposing a system into a set of functions or procedures. Each function performs a specific task or operation within the system, and the interactions between functions determine the overall behavior of the system. </br></br>

<h3>4. What are the quality parameters considered for effective modular design?</h3>
- For effective modular design in software engineering, several quality parameters are considered to ensure that the modules are well-designed, maintainable, and scalable. Here are some of the key quality parameters : </br></br>
i. High Cohesion: Modules should have high cohesion, meaning that the elements within the module are closely related and focused on performing a single, well-defined task or function. High cohesion reduces complexity and makes modules easier to understand, maintain, and reuse. </br></br>
ii. Low Coupling: Modules should have low coupling, meaning that they are loosely connected to other modules and have minimal dependencies on each other. Low coupling reduces the impact of changes in one module on other modules and promotes modular independence. </br></br>
iii. Encapsulation: Modules should encapsulate their internal details and provide well-defined interfaces for interacting with other modules. Encapsulation hides the implementation details of a module and allows it to be treated as a black box, making it easier to change and maintain. </br></br>
iv. Reusability: Modules should be designed to be reusable across different parts of the system or in different systems altogether. Reusable modules reduce development time and effort by allowing developers to leverage existing code instead of reinventing the wheel. </br></br>
v. Scalability: Modules should be designed to scale with the size and complexity of the system. Scalable modules can accommodate changes and additions to the system without requiring significant redesign or refactoring. </br></br>
vi. Testability: Modules should be designed to be easily testable in isolation. Testable modules facilitate unit testing, integration testing, and other forms of software testing, helping to ensure the correctness and reliability of the system. </br></br>
vii. Maintainability: Modules should be designed with maintainability in mind, making it easy to understand, modify, and extend the codebase over time. Maintainable modules follow best practices, such as clear naming conventions, proper documentation, and consistent coding style. </br></br>
viii. Flexibility: Modules should be designed to be flexible and adaptable to changing requirements and environments. Flexible modules can accommodate new features, technologies, and business rules without requiring extensive modifications to the existing codebase. </br>

<h1>Unit 5</h1>
